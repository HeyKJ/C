# 삽입 정렬

삽입 정렬은 한 요소를 뽑아내어 적당한 곳에 삽입하며 정렬을 하는 방법이다.  
쉽게 설명하면 카드 놀이를 할 때 카드를 5장 받았다고 치자.  
사람들은 받은 5장의 카드를 정렬하기 위해 한장씩 뽑아 적절한 위치에 넣는다.  

## 설명
1. 먼저 정렬 대상이 되는 요소들을 선택한다.  
정렬 대상은 왼쪽부터 선택해나가는데, 처음엔 2개이며 반복 횟수가 끝날 때 마다 정렬 대상은 1개씩 커진다.  
따라서 길이가 n인 배열의 정렬 대상 최대 범위는 n-1개이다.  

2. 정렬 대상의 가장 오른쪽에 있는 요소가 정렬 대상 중 가장 큰 값인지 확인한다.  
만일 그렇지 않다면 해당 요소를 뽑아내고 정렬 대상 중 위치해야 할 적절한 곳을 찾는다.  
즉 왼쪽에 위치한 요소보단 크고, 오른쪽에 위치한 요소보단 작은 곳 사이에 들어가야 한다.  

3. 적절한 위치를 찾았다면 그 찾은 위치의 오른쪽에 있는 요소들을 오른쪽으로 1칸씩 이동시킨다.  
이렇게 되면 빈 공간이 생기는데 그곳에 뽑은 요소를 집어넣는다.  
물론 적절한 위치는 정렬 대상 범위 내에서만 찾는다.

4. 모든 데이터가 정렬이 완료될 때 까지 1-3번을 반복한다.  

## 배열로 구현하기
아래와 같은 정수형 배열이 있다.  
``` int numberArray[] = {4, 2, 1, 3}; ```

**설명-1번**에 의거하여 정렬 대상은 왼쪽부터 선택해 나가고 그 대상은 2개이다.  
대상은 가장 왼쪽에 있는 두 개의 요소 4와 2가 되며 값을 비교하니 2가 더 작다.
**설명-2번**에 의거하여 2를 뽑는다.  
**{4, [], 1, 3}**

이제 **설명-3번**에 의거하여 뽑힌 2가 들어갈 자리는 4의 왼쪽 자리이다.  
그렇다면 4를 오른쪽으로 한 칸 이동시킨다.  
**{[], 4, 1, 3}**

이제 빈 공간이 생겼으므로 해당 자리에 2를 넣는다.  
**{2, 4, 1, 3}**

**설명-1번**에 의거하여 정렬 대상을 하나 더 늘린다.  
2, 4, 1이 정렬 대상이 되는데 가장 오른쪽에 1이 위치해 있고 바로 앞에는 4가 위치해있으므로 1을 뽑는다.  
**{2, 4, [], 3}**

정렬 대상을 순회하며 값을 비교해보니 1은 2랑 4보다 작으므로 2의 앞에 위치해야 한다.  
따라서 2와 4를 오른쪽으로 한 칸 이동시킨다.  
**{[], 2, 4, 3}**

이제 빈 공간에 1을 넣는다.  
**{1, 2, 4, 3}**

이제 정렬 대상을 하나 더 늘린다.  
모든 요소가 정렬 대상이 되었고 가장 오른쪽에 있는 3은 앞에 있는 4보다 작으므로 3을 뽑는다.  
**{1, 2, 4, []}**

값을 비교해보니 3은 4보다 작고 2보다 크므로 3이 위치할 곳은 4의 앞이다.  
따라서 4를 오른쪽으로 한 칸 이동시킨다.  
**{1, 2, [], 4}**

이제 빈 공간에 3을 집어 넣는다.  
**{1, 2, 3, 4}**

## 성능
정렬 대상의 요소가 4개였고 대상 범위가 2개였을 땐 1번, 3개일 땐 2번, 4개일 땐 3번의 비교를 수행한다.  
따라서 n개일 땐 n-1번의 비교를 수행하므로 아래와 같은 식을 얻을 수 있다.  
**삽입 정렬의 비교 횟수 = 1 + 2 + 3 + ... + (n-2) + (n-1) = n(n-1) / 2**

이 비교 횟수는 버블 정렬의 비교 횟수와 같지만 차이점이 있다.  
우리가 했던 예제를 보면 정렬 대상이 2개일 때 4와 2를 비교했으므로 비교 횟수는 1회이다.  
정렬 대상이 3개였을 땐 1과 4, 1과 2를 비교했으므로 비교 횟수는 2회이다.  
정렬 대상이 4개였을 땐 3과 4, 3과 2를 비교했으므로 비교 횟수는 2회이다.  

버블 정렬이였다면 1 + 2 + 3 = 6회 비교라는 성능이 나왔지만 실제 삽입 정렬에서는 1 + 2 + 2 = 5회뿐이였다.  
버블 정렬과 다르게 삽입 정렬은 정렬이 이미 되어있다면 한 번의 비교만 거친다.  
만일 위의 예제에서 아래와 같이 되있는 배열을 삽입 정렬로 정렬한다고 해보자.  
**{1, 2, 3, 4}**

최초 정렬 대상은 2개이므로 2와 1을 비교한다.  
2는 정렬 대상에서 가장 오른쪽에 위치하므로 다음 프로세스로 진행한다.  

이제 정렬 대상은 3개이다.  
3과 2를 비교해보니 3이 더 크고 가장 오른쪽에 위치하므로 다음 프로세스로 진행한다.  

이제 모든 요소가 정렬 대상이다.  
4와 3을 비교해보니 4가 더 크고 가장 오른쪽에 위치하므로 정렬을 종료한다.  

4개의 요소가 이미 정렬되어 있고 삽입 정렬 횟수는 1 + 1 + 1 = 3이다.  
그렇다면 n개의 요소가 삽입 정렬로 나올 수 있는 가장 이상적인 비교 횟수는 아래와 같다.  
**삽입 정렬 최소 비교 횟수 = n-1**

그럼 삽입 정렬의 평균 성능은 (최대 비교 횟수 + 최소 비교횟수) / 2이므로 아래와 같다.  
**삽입 정렬 평균 비교 횟수 = (n(n-1) / 2 + n-1) / 2 = (n^2 + n - 2) / 2**

확실한건 버블 정렬보다 나은 성능을 보여준다.  