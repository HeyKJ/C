# 퀵 정렬

전쟁 전략 중의 하나인 분할 정복(Divide and Conquer)에 기반한 알고리즘이다.  
전체를 공략하는 대신, 전체를 구성하는 구성 요소들을 나누어 잘개 쪼개진 적을 공략하는 전법이다.

## 설명
퀵 정렬은 다음과 같은 과정으로 분할 정복을 이용하여 정렬을 수행한다.  

1. 데이터 집합 내에서 임의의 요소를 선택하고, 기준 요소(피벗)보다 작은 요소들을 순서에 상관없이 왼쪽으로, 큰 값은 오른쪽에 위치시킨다.  
위 과정을 거치고 나면 피벗 왼편에는 피벗보다 작은 값들이, 오른쪽에는 피벗보다 큰 값들이 위치하게 된다.  
2. 피벗의 왼편에 위치하는 데이터들을 다시 1번 과정을 거친다.  
3. 피벗의 오른편에 위치하는 데이터들을 다시 1번 과정을 거친다.  
4. 더이상 데이터 집합을 나눌 수 없을 때까지 1~3번을 반복 

더블 링크드 리스트를 이용하여 구현한다면 피벗을 기준으로 요소들을 비교하며 작은 값들은 새로운 헤드 노드가 되고 큰 값들은 테일 노드가 된다.  
배열은 삽입/삭제가 자유롭지 못하기 때문에 구현한다면 어떻게 해야할까?  

## 배열을 이용하기
왼쪽에는 피벗보다 작은 값의 요소들만, 오른쪽에는 큰 값의 요소들만 위치시키는건 같다.  
하지만 삽입/삭제가 자유롭지 못하므로 우리는 두 명의 수색꾼을 지정하여 수색꾼들이 찾은 값들을 서로 교환하는 방법을 사용한다.   

왼쪽 수색꾼은 배열의 왼쪽부터 시작하여 차례대로 인덱스를 증가시키며 피벗과의 값을 비교한다.  
만일 피벗보다 큰 값을 만난다면 해당 위치에서 멈추고 인덱스를 반환한다.  
**왼쪽 수색꾼의 목표는 오로지 피벗보다 작은 값들만 위치시키기 위해 큰 값을 찾는 것이다.**

오른쪽 수색꾼은 배열의 오른쪽부터 시작하여 차례대로 인덱스를 감소시키며 피벗과의 값을 비교한다.  
만일 피벗보다 작은 값을 만난다면 해당 위치에서 멈추고 인덱스를 반환한다.  
**오른쪽 수색꾼의 목표는 오로지 피벗보다 큰 값들만 위치시키기 위해 작은 값들을 찾는 것이다.**
또 한 오른쪽 수색꾼이 수색한 마지막 위치는 피벗의 미래 위치다.  

이렇게 각각 왼쪽 수색꾼과 오른쪽 수색꾼이 반환한 인덱스의 값을 서로 교환한다.  
즉 피벗을 제외한 나머지 요소들을 미리 교환해 놓은다음 마지막에 피벗이 위치하는 것이다.  

그렇다면 수색할 범위를 지정해줘야 한다.  
지정한 left는 왼쪽 수색병이 인덱스를 증가하며 수색을 시작하는 위치이며  
right는 오른쪽 수색병이 인덱스를 감소하며 수색을 시작하는 위치이다.  

아래와 같은 정수형 배열이 있다.  
``` int numberArray[] = {1, 4, 2, 3}; ```

우리는 해당 배열을 정렬해야 하므로 배열 전체 요소가 수색 범위이다.  
``` int left = 0, right = 3; ```

편의를 위해 왼쪽 수색병이 위치하는 값을 피벗으로 지정한다.  
``` int pivot = numberArray[left]; ```

그럼 배열의 요소들은 아래와 같다.  
{1(**pivot, left**), 4, 2, 3(**right**)}

왼쪽 수색꾼의 위치는 본래 0번째 인덱스이지만 피벗도 0번째 인덱스이므로 피벗 다음 인덱스인 1, 오른쪽 수색꾼의 위치는 마지막 인덱스인 3이다.  
``` int leftS = 1, rightS = 3; ```  
{1(**pivot**), 4(**leftS**), 2, 3(**rightS**)}

이제 왼쪽 수색꾼은 자신의 시작 위치인 1번째 인덱스와 피벗의 값을 비교한다.  
피벗은 1이고 1번째 인데스의 값은 4이므로 왼쪽 수색꾼은 1번째 인덱스에 머무르겠다고 보고한다.  
``` leftS = 1; ```
{1(**pivot**), 4(**leftS**), 2, 3(**rightS**)}

이제 오른쪽 수색꾼이 자신의 시작 위치인 3번째 인덱스부터 피벗의 값을 비교한다.  
피벗보다 값이 크므로 이전 인덱스로 이동하여 검사한다.  
2번째 인덱스에 위치한 2도 피벗보다 크므로 이전 인덱스로 이동한다.  
첫번째 인덱스에 위치한 4도 피벗보다 크므로 이전 인덱스로 이동한다.  
0번째 인덱스에 위치한 1은 피벗과 값이 같다.  
그리고 오른쪽 수색꾼은 더이상 갈 곳이 없어 0번째 인덱스에 머무르겠다고 보고한다.  
``` rightS = 0; ```  
{1(**pivot, rightS**), 4(**leftS**), 2, 3}

왼쪽 수색병과 오른쪽 수색병이 모두 보고를 끝냈다.  
이제 결정을 내려야 하는데 왼쪽 수색병은 큰 값을 잘 찾았지만 오른쪽 수색병은 끝내 피벗보다 작은 값을 찾지 못했다.  
오른쪽 수색병은 임무에 실패했으므로 두 수색꾼 사이의 값 교환은 이뤄지지 않는다.  
그리고 오른쪽 수색병이 위치한 곳은 피벗이 있어야 할 위치이므로 둘 사이의 교환이 일어난다.  
물론 지금은 피벗과 오른쪽 수색병이 위치한 곳이 같으므로 의미가 없다.  

이제 한 번의 정렬이 끝났다.  
피벗을 중심으로 왼쪽에는 피벗보다 작은 값들이, 오른쪽에는 피벗보다 큰 값들이 모여 있다.  
이제 왼편에 모인 요소들로 다시한번 (**설명-4번**에 의거해서)**설명-1번**부터 시작한다.
마지막 피벗의 위치는 0번째 인덱스 이므로 **설명-2번**에 의거해서 다시 정렬을 실시한다.  
하지만 0번째 인덱스보다 왼편에 있을 수는 없으므로 **설명-3번**에 따라서 피벗의 오른쪽에 위치한 데이터들의 정렬을 실시한다.  
최초 범위는 left = 0, right = 3이였고, 마지막 피벗의 위치는 0이였다.  
그렇다면 **설명-3번**대로 마지막 피벗의 오른쪽은 1번째 인덱스부터 시작이며 해당 위치의 요소들을 정렬을 하기 위한 범위는 아래와 같다.  
``` left = 1, right = 3; ```
``` pivot = numberArray[left]; ```

이제 피벗은 1번째 인덱스 값인 4가 된다.  
{1, 4(**pivot, left**), 2, 3(**right**)}

처음 왼쪽 수색꾼의 위치는 피벗 다음 인덱스인 2, 오른쪽은 3에 위치한다.   
{1, 4(**pivot**), 2(**leftS**), 3(**rightS**)}

왼쪽 수색꾼은 피벗보다 큰 수를 찾지 못하고 마지막 인덱스인 3에 위치하여 수색을 종료한다.  
오른쪽 수색꾼의 시작 위치에 있는 값이 피벗 보다 작으므로 3번째 인덱스에 위치하겠다고 보고하고 수색을 종료한다.  
``` leftS = 3, rightS = 3; ```  
{1, 4(**pivot**), 2, 3(**leftS, rightS**)}

왼쪽과 오른쪽 수색꾼은 같은 위치에 있다.  
같은 위치에서 값을 교환해봤자 의미가 없으므로 교환은 일어나지 않는다.

마지막으로 오른쪽 수색꾼의 위치는 피벗이 있을 위치이므로 피벗과 rightS의 값을 교환해준다.  
{1, 3(**rightS**), 2, 4(**pivot**)}

현재 범위인 left = 1, right = 3의 정렬이 끝났고 마지막 피벗의 위치는 3이였다.  
따라서 **설명-2번**에 의거하여 마지막 피벗 왼쪽 요소들을 정렬한다.
``` left = 1, right = 2; ```
``` pivot = numberArray[left]; ```

이제 피벗은 1번째 인덱스 값인 3이 된다.  
{1, 3(**pivot, left**), 2(**right**), 4}

처음 왼쪽 수색꾼의 위치는 피벗 다음 인덱스인 2, 오른쪽도 2에 위치한다.   
{1, 3(**pivot**), 2(**leftS, rightS**), 4} 

왼쪽 수색꾼은 피벗보다 큰 값을 발견하지 못하여 다음 위치로 이동해야 하지만 현재 위치(2)가 범위의 끝이므로 수색을 종료한다.  
오른쪽 수색꾼의 시작 위치 값이 피벗보다 작으므로 보고하고 수색을 종료한다.   
leftS와 rightS가 같은 위치에 있으므로 값 교환은 일어나지 않는다.  
이제 pivot과 rightS의 위치 값을 바꿔준다.  
{1, 2(**rightS**), 3(**pivot**), 4}

범위는 left = 1, right = 2였고 마지막 피벗의 위치는 2번재 인덱스였으므로
피벗 왼쪽에 위치한 요소들을 정렬해야 한다. 하지만 그렇게 되면 범위는 left = 1, right = 1이므로 정렬은 의미가 없다.  
그렇다면 오른쪽 요소들을 정렬해야 하는데 마지막 피벗의 위치가 right 범위 끝이므로 오른쪽으로 정렬할 데이터가 없다.  
이제 범위 1-2까지의 정렬이 끝났다.

범위 1-2까지는 범위 1-3의 피벗 왼쪽에 위치한 요소들의 정리를 끝낸 것이므로
범위 1-3의 피벗 오른쪽에 위치한 요소들의 정리를 시작한다.  
물론 범위 1-3의 마지막 피벗 위치는 3이므로 오른쪽에 위치한 요소들은 없다.  

이제 범위 1-3의 정렬도 끝났다.  
범위 1-3은 범위 0-4의 오른쪽 요소들의 정리를 끝낸 것이다. 
따라서 정렬이 종료된다.  

내용이 너무 복잡한건 안다. [여기]("https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC")의 링크와 같이 참조하면 이해가 더욱 잘된다.
또한 시간 복잡도에 관한 증명식도 위 링크에 들어있으니 참고하면 된다.  
