퀵 정렬
=======

전쟁 전략 중의 하나인 분할 정복(Divide and Conquer)에 기반한 알고리즘이다.  
전체를 공략하는 대신, 전체를 구성하는 구성 요소들을 나누어 잘개 쪼개진 적을 공략하는 전법이다.

설명
====

퀵 정렬은 다음과 같은 과정으로 분할 정복을 이용하여 정렬을 수행한다.  

1. 데이터 집합 내에서 임의의 요소를 선택하고, 기준 요소(피벗)보다 작은 요소들을 순서에 상관없이 왼쪽으로, 큰 값은 오른쪽에 위치시킨다.  
위 과정을 거치고 나면 피벗 왼편에는 피벗보다 작은 값들이, 오른쪽에는 피벗보다 큰 값들이 위치하게 된다.  
2. 피벗의 왼편에 위치하는 데이터들을 다시 1번 과정을 거친다.  
3. 피벗의 오른편에 위치하는 데이터들을 다시 1번 과정을 거친다.  
4. 더이상 데이터 집합을 나눌 수 없을 때까지 1~3번을 반복 

사실 더블 링크드 리스트를 이용하여 구현하면 어렵지 않지만 삽입/삭제가 자유롭지 못한 배열을 이용하게 되면 난감한 상황이다.  
만일 피벗이 0번째 인덱스에 위치한다고 했을 때 피벗보다 작은 값을 왼쪽에 두려면 삽입 정렬처럼 한칸씩 뒤로 밀어놓고 추가하는 작업이 발생하게 된다.  
그렇다면 메모리 이동이나 배열을 길이를 동적으로 늘릴 필요없이 구현할 방법이 없을까?  

## 배열을 이용하기
배열에서 퀵 정렬을 사용하기 위해 우리는 두 명의 수색꾼을 지정한다.  
왼쪽 수색꾼은 배열의 왼쪽부터 시작하여 차례대로 인덱스를 증가시키며 피벗과의 값을 비교한다.  
만일 피벗보다 큰 값을 만난다면 해당 위치에서 멈추고 인덱스를 반환한다.  
즉 왼쪽 수색꾼의 목표는 오로지 피벗보다 작은 값들만 위치시키기 위해 큰 값을 찾는 것이다.  

오른쪽 수색꾼은 배열의 오른쪽부터 시작하여 차례대로 인덱스를 감소시키며 피벗과의 값을 비교한다.  
만일 피벗보다 작은 값을 만난다면 해당 위치에서 멈추고 인덱스를 반환한다.  
즉 오른쪽 수색꾼의 목표는 오로지 피벗보다 큰 값들만 위치시키기 위해 작은 값들을 찾는 것이다.  

또한 수색할 범위를 지정해줘야 한다.  
지정한 left부터 right까지 수색을 진행하라는 명령이다.  
두 수색병은 해당 명령을 토대로 수색을 진행한다.  

만일 아래와 같은 배열이 있다고 가정하자.  
``` int numberArray[] = {1, 4, 2, 3}; ```

그렇다면 수색 범위는 0번째 인덱스 부터 3번째 인덱스가 된다.  
``` int left = 0, right = 3; ```

편의를 위해 left 위치에 있는 값을 피벗으로 지정한다.  
``` int pivot = numberArray[left]; ```

{1(**pivot, left**), 4, 2, 3(**right**)}

왼쪽 수색꾼의 위치는 피벗 다음 인덱스인 1, 오른쪽 수색꾼의 위치는 마지막 인덱스인 3이다.  
``` int leftS = 1, rightS = 3; ```  
{1(**pivot**), 4(**leftS**), 2, 3(**rightS**)}

이제 왼쪽 수색꾼은 첫번째 인덱스와 피벗의 값을 비교한다.  
피벗보다 더 큰 값을 찾았으므로 왼쪽 수색꾼은 첫번째 인덱스에 머무르겠다고 보고한다.  
``` leftS = 1; ```
{1(**pivot**), 4(**leftS**), 2, 3(**rightS**)}

이제 오른쪽 수색꾼이 3번째 인덱스부터 피벗의 값을 비교한다.  
피벗보다 값이 크므로 이전 인덱스로 이동하여 검사한다.  
2번째 인덱스에 위치한 2도 피벗보다 크므로 이전 인덱스로 이동한다.  
첫번째 인덱스에 위치한 4도 피벗보다 크므로 이전 인덱스로 이동한다.  
0번째 인덱스에 위치한 1은 피벗과 값이 같다.  
그리고 오른쪽 수색꾼은 더이상 갈 곳이 없어 0번째 인덱스에 머무르겠다고 보고한다.  
``` rightS = 0; ```  
{1(**pivot, rightS**), 4(**leftS**), 2, 3}

만일 왼쪽 수색꾼이 오른쪽 수색꾼보다 더 이전 인덱스에 머물러 있었다면(leftS < rightS) , 다시말해  
왼쪽 수색꾼과 오른쪽 수색꾼은 서로를 만나기 전에 각각 피벗보다 큰 값과 작은 값을 발견했다면
leftS와 rightS가 위치하는 값을 스왑한다.  

하지만 현재는 rightS < leftS이므로 아무런 값도 swap되지 않는다.(즉 왼쪽 수색꾼과 오른쪽 수색꾼은 서로를 만나기 전에 각각 피벗보다 큰 값과 작은 값을 발견하지 못했단 얘기)  
이제 마지막으로 피벗의 위치와 rightS위치를 스왑해줘야 한다.(물론 현재는 피벗의 위치와 rightS위치가 같으므로 스왑은 의미없다.)  

이유를 생각해보면 간단하다.  
왼쪽 수색꾼 leftS는 피벗보다 큰 값을 만나면 그자리에 멈춘다.
그리고 오른쪽 수색꾼 rightS는 피벗보다 작은 값을 만나면 그자리에 멈춘다.  
이후 두 값은 스왑된 후 다시 왼쪽 수색꾼은 수색을 시작하고 오른쪽 수색꾼도 다음 수색을 시작한다.  
이러한 수색이 모두 종료되었다고 가정하자.  
왼쪽 수색꾼과 오른쪽 수색꾼은 서로 같은 위치에 있거나 다른 위치에 있을 것이다.  

leftS가 rightS가 있는 곳까지 도달했다고 가정하자.  
즉 왼쪽 수색꾼이 오른쪽 수색꾼과 같은 위치에서 만났다는 거다.  
왼쪽 수색꾼이 먼저 수색 활동을 시작하므로 오른쪽 수색꾼의 위치까지 올라갔다는 것은 
**피벗보다 큰 수를 찾지 못하였기 때문**이다.  

그렇다면 왼쪽 수색꾼 입장에서는 피벗이 가장 큰 수일 것이다.  
이제 오른쪽 수색꾼이 활동을 시작한다.  
왼쪽 수색꾼이 자기 위치까지 올라왔다는 것은 피벗보다 큰 수를 찾지 못함이다.  
다시 말해 올라오는 동안 피벗보다 작은 수만 존재했다는 것이므로 오른쪽 수색꾼의 시작 위치에 있는 값은 피벗보다 작은 값일 것이다. (leftS와 동일한 위치에 있음)  
그렇다면 가장 작은 값인 rightS의 위치는 피벗 위치의 값과 서로 스왑되어야 한다.  
이를 통해 알 수 있듯이 마지막 오른쪽 수색꾼의 위치는 미래의 피벗 위치이다.  

이제 한 번의 정렬이 끝났다.  
피벗을 중심으로 왼쪽에는 피벗보다 작은 값들이, 오른쪽에는 피벗보다 큰 값들이 모여 있다.  
이제 왼편에 모인 요소들로 다시한번 (**설명-4번**에 의거해서)**설명-1번**부터 시작한다.
마지막 피벗의 위치는 0번째 인덱스 이므로 **설명-2번***에 의거해서 다시 정렬을 실시한다.  
하지만 0번째 인덱스보다 왼편에 있을 수는 없으므로 **설명-3번**에 의거해서 다시 정렬을 실시한다.  
최초 left는 0이였고 right는 3이였고, 마지막 피벗의 위치는 0이였다.  
따라서 **설명-3번**대로 피벗의 오른쪽에 위치하는 요소들로 정렬을 하기 위한 범위는 아래와 같다.  
``` left = 1, right = 3; ```
``` pivot = numberArray[left]; ```

이제 피벗은 첫번째 인덱스 값인 4가 된다.  
{1, 4(**pivot, left**), 2, 3(**right**)}

처음 왼쪽 수색꾼의 위치는 피벗 다음 인덱스인 2, 오른쪽은 3에 위치한다.   
{1(**end**), 4(**pivot**), 2(**leftS**), 3(**rightS**)}

왼쪽 수색꾼은 피벗보다 큰 수를 찾지 못하고 마지막 인덱스인 3에 위치한다.  
오른쪽 수색꾼은 피벗 보다 작은 값인 3이 위치한 3번째 인덱스에 위치한다.  
``` leftS = 3, rightS = 3; ```  
{1(**end**), 4(**pivot**), 2, 3(**leftS, rightS**)}

leftS와 rightS의 값이 같으므로 leftS와 rightS의 값 스왑은 일어나지 않는다. (같은 위치에 있기 때문)  

마지막으로 피벗의 위치와 rightS위치의 값을 스왑해준다.  
{1(**end**), 3(**rightS**), 2, 4(**pivot**)}

현재 범위인 left = 1, right = 3인 정렬이 끝났고 마지막 피벗의 위치는 3이였다.  
따라서 **설명-2번***에 의거하여 피벗 왼쪽 요소들을 정렬하기 위해 
left = 1, right = 2인 범위에서 시작한다.  
피벗은 1번째 인데스 값인 3이 된다.  
``` left = 1, right = 2; ```
``` pivot = numberArray[left]; ```

이제 피벗은 첫번째 인덱스 값인 3가 된다.  
{1(**end**), 3(**pivot, left**), 2(**right**), 4(**end**)}

처음 왼쪽 수색꾼의 위치는 피벗 다음 인덱스인 2, 오른쪽도 2에 위치한다.   
{1(**end**), 3(**pivot**), 2(**leftS, rightS**), 4(**end**)} 

왼쪽 수색꾼은 피벗보다 큰 값을 발견하지 못하여 다음 위치로 이동해야 하지만 현재 위치(2)가 범위의 끝이므로 수색을 종료한다.  
오른쪽 수색꾼은 피벗보다 작은 값을 발견하여 그 자리에 위치한다.  
leftS와 rightS가 같은 위치에 있으므로 둘 위치 값의 스왑은 일어나지 않는다.  
이제 pivot과 rightS의 위치 값을 바꿔준다.  
{1(**end**), 2(**rightS**), 3(**pivot**), 4(**end**)}




