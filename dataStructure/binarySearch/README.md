# 이진 탐색
이진 탐색은 **정렬된 데이터 집합**에서 사용할 수 있는 고속 탐색 알고리즘이다.  

## 설명
이 알고리즘의 핵심은 탐색 범위를 1/2씩 줄여나가는데에 있다.  
정수형 배열이 오름차순으로 정렬되어있다고 가정하자.  
이진 탐색은 아래와 같은 프로세스로 진행된다.  

1. 데이터 집합의 중앙에 있는 요소를 정한다.  
2. 중앙 요소의 값과 찾고자 하는 목표 값을 비교한다.  
3. 목표 값이 중앙 요소의 값보다 작다면 중앙 요소보다 왼쪽에 있다는 뜻이므로  
현재 중앙 요소의 왼편 데이터 집합에 대해 새로운 탐색을 시작하고,
목표 값이 중앙 요소의 값보다 크다면 현재 중앙 요소의 오른편 데이터 집합에 대해 탐색을 시작한다.  
4. 목표 값을 찾을 때 가지 1-3번을 반복한다.  

길이가 10인 정수형 배열이 오름차순으로 정렬되어있다.  
``` int numberArray[] = {1, 3, 5, 6, 7, 8, 9, 10, 11, 12}; ```

우리의 목표 값은 5를 찾는 것이다.  
``` int targetData = 5; ```

최초 범위는 0번째 인덱스부터 배열의 마지막 인덱스까지이고 중앙 값은 (0 + 9) / 2이므로 4가된다.  
``` int left = 0, right = 9, mid = (left + right) / 2; ```

4번째 인덱스의 값은 7이다.
목표 값(5)은 7보다 작으므로 목표 값이 7을 기준으로 왼편에 있다는 것을 알 수 있다.  
따라서 우리의 탐색 범위는 0번째 인덱스부터 현재 중앙 요소의 이전 인덱스까지로 좁혀진다.  
``` left = 0, right = mid - 1, mid = (left + right) / 2; ```

범위는 0-3까지, 중앙 요소는 1이므로 중앙 요소의 값은 3이 된다.
목표 값(5)은 3보다 크므로 3보다 오른편에 위치한다는 것을 알 수 있다.  
다시 탐색 범위는 이전 중앙 요소의 다음 인덱스부터 3까지가 된다.  
``` left =  mid + 1, right = 3, mid = (left + right) / 2; ```

지난 mid 값은 1이였으므로 left = 2, right = 3, mid = 2가된다.
중앙 요소의 값은 5이므로 우리가 찾는 목표 값과 일치한다.  

## 성능
이진 탐색은 순차 탐색보다 확실히 압도적인 성능을 보인다.  
가장 큰 매력은 한 번의 탐색이 끝날 때 마다 탐색 범위가 1/2씩 줄어든다는 점이다.  
n개의 데이터 집합에서 탐색 횟수 x는 아래와 같다.  
**x = logn**

1,000만개의 데이터도 23회 탐색을 반복하면 값을 찾을 수 있다.  
