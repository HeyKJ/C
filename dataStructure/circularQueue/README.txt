순환큐

스택과는 다르게 FIFO 즉 가장 먼저 들어온 데이터가 가장 먼저 나가는 구조이다.
일반적으로 길이가 5인 배열을 생각해보자.
큐에서는 첫번째 들어온 데이터에 전단, 마지막 들어온 데이터에 후단이라는 꼬리표가 달린다.
최초에는 전단과 후단이 같은 위치에 있을 것이다.

(전단)(후단)[empty] - [empty] - [empty] - [empty] - [empty]

이제 데이터를 추가해보겠다.

(전단)(후단)[0] - [empty] - [empty] - [empty] - [empty]

큐에서는 첫번째 들어온 데이터에 전단, 마지막 들어온 데이터에 후단이라는 꼬리표가 달린다는 사실로 보면
큐가 비어있든 첫번째 데이터가 존재하든 전단과 후단의 위치는 변함이 없다.
큐가 실제 비어있는지, 첫번째 데이터만 존재하는건지 알려면 루프 탐색(반복문)을 실행할 수 밖에 없다.
따라서 후단은 데이터가 추가되었다면 실제 인덱스보다 한 칸 더 뒤에 존재해야 한다.

(전단)[0] - (후단)[empty] - [empty] - [empty] - [empty]

이로써 큐가 비어있는 상태일 때와 데이터가 있는 상태를 구별할 수 있다.
데이터를 2개만 더 넣어보자.

(전단)[0] - [1] - [2] - (후단)[empty] - [empty]

이제 데이터를 반환해보겠다.
FIFO 구조이니 첫번째 들어온 데이터 0이 반환될 것이다.

[empty] - (전단)[1] - [2] - (후단)[empty] - [empty]

전단에 있던 데이터 0을 반환하고 다음 인덱스로 이동하였다.
보통 이렇게 되어버리면 첫번째 공간이 비어있으니 앞으로 한 칸씩 이동하고 싶을 것이다.
왜냐면 큐는 FIFO 구조이기 때문에 처음 데이터가 첫번째 인덱스에 있어야된다는 생각에..

(전단)[1] - [2] - (후단)[empty] - [empty] - [empty]

하지만 데이터가 100개라면 어떨까?
99번의 이동이 일어나야하므로 최악의 알고리즘이라 할 수 있다.

그래서 순환큐가 나왔다.
아래 구조를 보면 이해가 갈 것이다.

*데이터 3 추가
[empty] - (전단)[1] - [2] - [3] - (후단)[empty]

*데이터 4 추가
(후단)[empty] - (전단)[1] - [2] - [3] - [4]

*데이터 5 추가
[5] - (전단)(후단)[1] - [2] - [3] - [4]

이렇듯 전단과 후단의 위치만 안다면 불필요한 데이터 이동과정없이 배열을 순환하여 이용할 수 있다.
그런데 문제가 생겼다.

[5] - (전단)(후단)[1] - [2] - [3] - [4]

현재 전단과 후단의 위치가 같은 곳에 있다.
이렇게 되버리면 또다시 empty상태인지 full상태인지 구별할 수가 없다.
그래서 실제 선언된 배열 길이보다 한 칸 더 긴 더미 공간이 하나 필요하다.

*실제 데이터가 들어가는 곳은 5곳이지만 더미 공간이 포함되 6칸이 됨
[5] - (후단)[empty] - (전단)[1] - [2] - [3] - [4]

이렇게 함으로써 전단 앞에 후단이 존재한다면 큐는 Full 상태임을 알 수 있다.

*큐 데이터 반환(1이 반환됨)
[5] - (후단)[empty] - [empty] - (전단)[2] - [3] - [4]

*데이터 6 추가
[5] - [6] - (후단)[empty] - (전단)[2] - [3] - [4]

항상 더미 공간에 후단이 존재해야 한다.
