# 이진 탐색 트리
이진 탐색을 위한 이진 트리이다.

## 설명
이진 탐색 트리는 이진 탐색을 위한 트리이다.  
이진 탐색 알고리즘은 데이터 집합의 시작과 끝을 알아야하고, 중앙 요소에 바로 접근이 가능해야 한다.  
따라서 배열에는 적합하지만 링크드 리스트같이 동적으로 데이터 집합의 크기가 커지는 자료구조에 적용시키기에는 약간의 어려움이 있다.  
이러한 문제를 해결해주는 자료구조가 바로 이진 탐색 트리(Binary Search Tree)이다.

### 구조
이진 탐색 트리는 아래와 같은 구조로 이루어져 있다.  

- 왼쪽 자식 노드는 중앙 노드보다 값이 작다.  
- 오른쪽 자식 노드는 중앙 노드보다 값이 크다.

### 이진 탐색 트리에서 이진 탐색
위 구조를 토대로 이진 탐색을 실시한다면 아래와 같다.  

1. 목표 값과 중앙 노드의 값을 비교한다.
2. 목표 값이 중앙 노드의 값과 같다면 탐색을 종료한다.  
3. 목표 값이 중앙 노드보다 작을 경우 중앙 노드의 왼쪽 노드로 이동한다.  
4. 목표 값이 중앙 노드보다 클 경우 중앙 노드의 오른쪽 노드로 이동한다.  
5. 목표 값을 찾을 때 까지 1-4번을 반복한다.

### 이진 탐색 트리에 노드 추가
이진 탐색 트리에 노드를 새로 추가하는 것도 위 두가지 규치만 따르면 된다.  
추가하고자 하는 노드의 값이 중앙 노드보다 작다면 왼쪽 자식이, 크다면 오른쪽 자식이 된다.  
만일 기존에 자식 노드가 존재한다면 다시 비교 연산을 통해서 자식 노드가 될지, 아니면 다시 자식 노드로 이동하여 비교 연산을 할 지 정한다.

### 이진 탐색 트리에서 노드 삭제
만일 이진 탐색 트리에서 삭제 할 노드가 리프(잎) 노드라면 삭제 할 노드와 부모 노드의 연결을 끊어주면 된다.  
왜냐면 리프 노드는 트리 구조에서 최하단 노드라서 자식이 없기 때문이다.  
하지만 삭제 할 노드가 브랜치나 루트 노드가 된다면 아래 자식들을 고려해야 하기 때문에 우리는 세가지 상황을 생각해야 한다.  

#### 자식이 아예 없다.
자식이 아예 없다면 리프 노드이므로 부모 노드가 가지고 있는 삭제 할 노드의 주소를 NULL로 만들어주면 된다.  

#### 자식이 하나만 있다.
삭제 할 노드의 자식이 하나뿐이라면 삭제 할 노드의 부모 노드와 삭제 할 노드의 하나뿐인 자식 노드를 이어주면 된다.  

### 자식이 둘다 있다.
삭제 할 노드의 자식이 둘다있는 경우라면 오른쪽 자식들 중 가장 작은 값을 가진 노드를 삭제 될 노드로 옮긴다.  

![이진 탐색 트리](https://t1.daumcdn.net/cfile/tistory/2321CB4951A467AC0B)  
**출처[http://blog.eairship.kr/248]**

여기서 10을 삭제한다고 가정하자.
위 규칙대로 오른쪽 자식들(14 17, 21) 중 가장 작은 값인 14가 10의 위치를 대신하게 된다.  
14는 가장 작은 최소값을 가지고 있으므로 자식이 아예 없거나 오른쪽 자식이 하나 있을 수 있다.  
(최소값은 가장 왼편에 위치하기 때문에 최소값이 왼쪽 자식을 가질 수 없다)  
자식이 없다면 14를 10에 위치시키면 끝이지만 14가 15라는 오른쪽 자식을 갖고 있었다면 15와 17을 연결해주고
14는 10의 자리로 위치하면 된다.  
14가 10의 자리에 위치하면 5보다 크고 17보다 작으니 이진 탐색 트리 구조다.





