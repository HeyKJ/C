# 합병 정렬

퀵 정렬과 마찬가지로 분할 정복 알고리즘을 사용한다.  
합병 정렬은 더 이상 나눠지지 않을 정도로 분할하고 합치면서 정렬하는 방식이다.  

## 설명
아래와 같은 정수형 배열이있다. 
``` int numberArray[] = {3, 1, 4, 5, 2}; ```

정렬하고자 하는 범위는 모든 배열 요소이므로 아래와 같다.  
``` int left = 0, right = 4; ```

정렬 범위의 중간 위치는 2번째 인덱스이다.  
``` int mid = (left + right + 1) / 2; ```

이제 mid를 기준으로 반으로 쪼개면 두 개의 배열로 나뉜다.  
**조각1 = {3, 1, 4}**  
**조각2 ={5, 2}**

우리는 더 이상 나눠지지 않을 때 까지 계속 나눠야한다.  
다시 조각1을 나눈다.  
``` left = 0, right = 2, mid  = 1; ```

그렇다면 아래와 같은 조각이 나온다.  
**조각1-1 = {3, 1}**  
**조각1-2 = {4}**

조각1-1은 충분히 나눠질 수 있다. 다시 나눠보자.  
``` left = 0, right = 1, mid  = 1; ```

그렇다면 아래와 같은 조각이 나온다.  
**조각1-1-1 = {3}**  
**조각1-1-2 = {1}**

더 이상 나눌 수 없으므로 두 조각을 합친다.  
이 때 두 값을 비교한다. 조각1-1-2가 더 작으므로 이 값이 먼저 위치해야한다.  
우선 임시 배열에 차례대로 값을 저장한다.  
**임시 배열 {1, 3, 0, 0, 0}**

left는 0이고 right는 1이므로 0-1 인덱스까지의 임시 배열 값을 기존 배열에 대입한다.  
**기존 배열 {1, 3, ?, ?, ?}**

이제 조각1-1에 대한 합병 정렬은 끝났다.  
조각1-2는 더 이상 쪼갤 수 없으므로 조각1-1과 조각1-2를 합병 정렬한다.  
**조각1-1 = {1, 3}**  
**조각1-2 = {4}**

우선 조각1-1의 첫번째 요소인 1과 조각1-2의 첫번째 요소인 4를 비교한다.  
1이 더 작으므로 임시 배열엔 1이 처음으로 위치하게 된다.  
**임시 배열 {1, 0, 0, 0, 0}**

이제 조각1-1은 다음 인덱스로 위치하여 다시 조각1-2와 값을 비교한다.  
3이 더 작으므로 임시 배열엔 3이 추가된다.  
**임시 배열 {1, 3, 0, 0, 0}**

조각1-1엔 더 이상 비교할 요소가 없으므로 나머지 조각1-2에 있는 요소를 임시 배열에 넣어준다.  
**임시 배열 {1, 3, 4, 0, 0}**

임시 배열의 값을 조각1의 범위 만큼 값을 대입한다.  
**기존 배열 {1, 3, 4, ?, ?}**

조각1에 대한 합병 정렬이 끝났으므로 조각2에 대한 합병 정렬을 시작한다.  
``` left = 3, right = 4, mid  = 4; ```

mid가 4이므로 4를 기준으로 조각2는 또 다시 두조각을 나뉜다.  
**조각2-1 = {5}**  
**조각2-2 = {2}**

더 이상 나눌 수 없으므로 두 요소를 비교하여 임시 배열에 저장한다.  
2가 더 작으므로 임시 배열에 저장된 값은 아래와 같다.  
참고로 조각2의 범위는 left = 3, right = 4이다.  
**임시 배열 {0, 0, 0, 2, 5}**

조각2에 대한 합병 정렬도 끝났으므로 조각1과 조각2에 대해 합병 정렬을 시작한다.  
**조각1 = {1, 3, 4}**
**조각2 = {2, 5}**

조각1의 첫번째 요소와 조각2의 첫번째 요소를 비교한다.  
1이 더 작으므로 임시 배열엔 1이 추가된다.  
**임시 배열 {1, 0, 0, 0, 0}**

이제 조각1의 두번째 요소와 조각2의 첫번째 요소를 비교한다.  
2가 더 작으므로 임시 배열에 2가 추가된다.  
**임시 배열 {1, 2, 0, 0, 0}**

조각1의 두번째 요소와 조각2의 두번째 요소를 비교한다.  
3이 더 작으므로 임시 배열엔 3이 추가된다.  
**임시 배열 {1, 2, 3, 0, 0}**

조각1의 세번째 요소와 조각2의 두번째 요소를 비교한다.  
4가 더 작으므로 임시 배열엔 4가 추가된다.  
**임시 배열 {1, 2, 3, 4, 0}**

조각1엔 남은 요소가 없으므로 조각2에 남은 요소들을 차레대로 임시 배열에 추가한다.  
**임시 배열 {1, 2, 3, 4, 5}**

조각1과 조각2로 나누기전에 최초 범위는 left = 0, right = 4였다.  
따라서 0-4 범위의 임시 배열 값을 기존 배열로 옮긴다.  
**기존 배열 {1, 2, 3, 4, 5}**

## 성능
결론부터 얘기하자면 nlogn이다.  
[여기](http://new93helloworld.tistory.com/104)를 가보면 이미지와 함께 친절히 설명되어있다.  