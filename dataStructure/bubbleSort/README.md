버블 정렬
=========

근접한 이웃 요소끼리 교환을 통해 정렬을 수행하는 방법이다.  

설명
====
길이가 6인 정수형 배열이 있고 오름차순으로 정렬한다고 가정하자.  

**5 1 6 4 2 3**  
처음에 0번째 인덱스와 와 1번째 인덱스를 비교한다. 5가 더 크므로 1과 5의 위치를 바꾼다.  
**1 5 6 4 2 3**  
이제 1번째 인덱스와 2번째 인덱스를 비교한다. 5가 더 작으므로 교환이 일어나지 않는다.  
**1 5 6 4 2 3**  
이제 2번째 인덱스와 3번째 인덱스를 비교한다. 6이 더 크므로 6과 4의 위치를 바꾼다.  
**1 5 4 6 2 3**  
이제 3번째 인덱스와 4번째 인덱스를 비교한다. 6이 더 크므로 6과 2의 위치를 바꾼다.  
**1 5 4 2 6 3**  
이제 4번째 인덱스와 5번째 인덱스를 비교한다. 6이 더 크므로 6과 3의 위치를 바꾼다.  
**1 5 4 2 3 6**  
[정렬 범위는 5번째 인덱스까지이며 총 5번 비교가 일어났음]

정렬을 했는데 아직 정렬이 완벽히 되지 않았다.  
다시 정렬을 반복해야하는데 이 때 마지막 인덱스를 제외하고 반복한다.

**1 5 4 2 3 6**  
처음에 0번째 인덱스와 와 1번째 인덱스를 비교한다. 1이 더 작으므로 교환이 일어나지 않는다.  
**1 5 4 2 3 6**  
이제 1번째 인덱스와 2번째 인덱스를 비교한다. 5가 더 크므로 5와 4의 위치를 바꾼다.  
**1 4 5 2 3 6**  
이제 2번째 인덱스와 3번째 인덱스를 비교한다. 5가 더 크므로 5와 2의 위치를 바꾼다.  
**1 4 2 5 3 6**  
이제 3번째 인덱스와 4번째 인덱스를 비교한다. 5가 더 크므로 5와 3의 위치를 바꾼다.  
**1 4 2 3 5 6**  
[정렬 범위는 4번째 인덱스까지이며 총 4번 비교가 일어났음]

정렬을 했는데 아직도 완벽하지 않다.  
다시 정렬을 반복해야하는데 이 때 비교했던 마지막 인덱스를 제외하고 반복한다.

**1 4 2 3 5 6**  
처음에 0번째 인덱스와 와 1번째 인덱스를 비교한다. 1이 더 작으므로 교환이 일어나지 않는다.  
**1 4 2 3 5 6**  
이제 1번째 인덱스와 2번째 인덱스를 비교한다. 4가 더 크므로 4와 2의 위치를 바꾼다.  
**1 2 4 3 5 6**  
이제 2번째 인덱스와 3번째 인덱스를 비교한다. 4가 더 크므로 4와 3의 위치를 바꾼다.  
**1 2 3 4 5 6**  
[정렬 범위는 3번째 인덱스까지이며 총 3번 비교가 일어났음]

이제 정렬이 되었다.  
사람이 보기엔 정렬이 되었구나 알 수 있지만 프로그램은 실제 비교문을 통해서만 알 수 있다.  
따라서 다시 정렬을 반복해야하는데 이 때 비교했던 마지막 인덱스를 제외하고 반복한다.

**1 2 3 4 5 6**  
처음에 0번째 인덱스와 와 1번째 인덱스를 비교한다. 1이 더 작으므로 교환이 일어나지 않는다.  
**1 2 3 4 5 6**  
이제 1번째 인덱스와 2번째 인덱스를 비교한다. 2가 더 작으므로 교환이 일어나지 않는다.  
**1 2 4 3 5 6**  
[정렬 범위는 2번째 인덱스까지이며 총 2번 비교가 일어났음]

이제 남은 정렬 범위는 1번째 인덱스까지이며 총 1번의 비교가 일어날 것이다.  
**1 2 3 4 5 6**  
처음에 0번째 인덱스와 와 1번째 인덱스를 비교한다. 1이 더 작으므로 교환이 일어나지 않는다.  
**1 2 4 3 5 6**  
[정렬 범위는 1번째 인덱스까지이며 총 1번 비교가 일어났음]

한 번의 정렬이 끝날 때마다 배열 길이가 1씩 감소하는 것을 알 수 있다.  
현재 길이가 6인 정수형 배열을 정렬하는데 걸린 반복 횟수는 5 + 4 + 3 + 2 + 1 = 15번이 나왔다.  
즉 길이가 n인 배열을 정렬하는데 걸리는 반복 횟수를 표현하면 아래와 같다.  
**n-1 + n-2 + n-3... n-(n-1)**  
여기서 n-(n-1)는 1이므로 결국 1부터 n-1까지의 합을 구한다고 볼 수 있다. 여기서 가우스의 계산법을 활용하면 아래와 같다.  
길이가 n인 배열의 버블 정렬 반복 횟수 = n * (n-1) / 2  
이를 통해 알 수 있듯이 성능이 좋은 정렬 알고리즘은 아니다.