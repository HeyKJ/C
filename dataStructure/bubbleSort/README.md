# 버블 정렬

근접한 이웃 요소끼리 교환을 통해 정렬을 수행하는 방법이다.  

## 설명
버블 정렬은 이웃한 요소끼리 값을 비교하여 교환을 통해 정렬해간다.  
아래는 임의의 요소들을 오름차순으로 정렬한다고 가정한다.  

1. 0번째와 1번째 인덱스에 위치한 값을 비교하고 1번째 인덱스에 위치한 값이 더 작다면 0번째 인덱스와 값을 교환한다.  
2. 1번째와 2번째 인덱스에 위치한 값을 비교하여 2번째 인덱스에 위치한 값이 더 작다면 1번째 인덱스와 값을 교환한다.  
3. ....
4. n-2번와 n-1번째 인덱스에 위치한 값을 비교하여 n-1번째 인덱스에 위치한 값이 더 작다면 n-2번재 인덱스와 값을 교환한다.  
5. 정렬 범위의 가장 오른쪽에 있는 요소를 제외하고 다시 1-3번을 반복한다.  
버블 정렬은 n개의 요소를 정렬하고자 한다면 정렬 범위는 반복 횟수가 끝날 때 마다 1씩 줄어든다.  
최초 정렬 범위는 0번째 인덱스부터 n-1번째 인덱스까지이며
다음 정렬 범위는 0번째 인덱스부터 n-2번째 인덱스까지
....
마지막 정렬 범위는 0번째 인덱스부터 1번째 인덱스까지이다.  

아래와 같은 정수형 배열이 있다.  
``` int numberArray[] = {5, 1, 6, 4, 2, 3}; ```  

5와 1을 비교하니 1이 더 작으므로 둘의 위치를 바꾼다.  
**{1, 5, 6, 4, 2, 3}**  

5와 6을 비교하니 6이 더 크므로 넘어간다.  

6과 4를 비교하니 4가 더 작으므로 둘의 위치를 바꾼다.  
**{1, 5, 4, 6, 2, 3}**  

6과 2를 비교하니 2가 더 작으므로 둘의 위치를 바꾼다.  
**{1, 5, 4, 2, 6, 3}**  

6과 3를 비교하니 3이 더 작으므로 둘의 위치를 바꾼다.  
**{1, 5, 4, 2, 3, 6}**

이렇게 한 번의 정렬이 끝났다.   
최초 정렬 범위는 배열의 모든 요소였다.  
**설명 5번**에 의거하여 한 번의 정렬이 끝났으니 가장 오른쪽에 있는 6을 제외한다.  
따라서 정렬 범위는 0번째 인덱스부터 4번째 인덱스까지이다.  

1과 5를 비교하니 5가 더 크므로 넘어간다.  

5와 4를 비교하니 4가 더 작으므로 둘의 위치를 바꾼다.  
**{1, 4, 5, 2, 3, 6}**

5와 2를 비교하니 2가 더 작으므로 둘의 위치를 바꾼다.  
**{1, 4, 2, 5, 3, 6}**

5와 3를 비교하니 3가 더 작으므로 둘의 위치를 바꾼다.  
**{1, 4, 2, 3, 5, 6}**

정렬 범위는 4번째 인덱스까지였으므로 또 한 번의 정렬이 끝났다.  
**설명 5번**에 의거하여 한 번의 정렬이 끝났으니 범위는 또 줄어들어 0번째 부터 3번째 인덱스까지이다.  

1과 4를 비교하니 4가 더 크므로 넘어간다.  

4와 2를 비교하니 2가 더 작으므로 둘의 위치를 바꾼다.  
**{1, 2, 4, 3, 5, 6}**

4와 3를 비교하니 3이 더 작으므로 둘의 위치를 바꾼다.  
**{1, 2, 3, 4, 5, 6}**

정렬은 끝났지만 컴퓨터는 이 정렬이 끝났는지 알 수 없다.  
어쩔 수 없이 남은 정렬을 수행하여 정렬이 완벽하게 되었는지 검사하는 방법밖엔 없으니  
다시 **설명 5번**에 따라서 범위는 또 줄어들어 0번째 부터 2번째 인덱스까지이다.  

1과 2를 비교하니 2가 더 크므로 넘어간다.  

2와 3을 비교하니 3이 더 크므로 넘어간다.  

다시 **설명 5번**에 따라서 범위는 또 줄어들어 0번째 부터 1번째 인덱스까지이다.  

1과 2를 비교하니 2가 더 크므로 넘어간다.  

## 성능
현재 길이가 6인 정수형 배열을 정렬하는데 걸린 반복 횟수는 5 + 4 + 3 + 2 + 1 = 15번이 나왔다.  
따라서 길이가 n인 배열을 정렬하는데 걸리는 반복 횟수를 표현하면 아래와 같다.  
**버블 정렬 반복 횟수 = n-1 + n-2 + n-3... n-(n-1)**  
여기서 n-(n-1)는 1이므로 결국 1부터 n-1까지의 합을 구한다고 볼 수 있으므로 가우스의 계산법을 활용하면 아래와 같다.  
**버블 정렬 반복 횟수 = n * (n-1) / 2**  

버블 정렬은 성능이 좋은 알고리즘은 아니지만 구현하기가 쉽기때문에 정렬하는 요소가 별로 없다면 사용하기 적합하다.  